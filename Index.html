<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Endless Bouncer</title>
  <style>
    body {
      background: #292A37;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #gameContainer {
      width: 100vw;
      height: 100vh;
      position: relative;
      border: 2px solid ghostwhite;
      box-sizing: border-box;
      overflow: hidden;
    }

    #character {
      width: 50px;
      height: 50px;
      position: absolute;
      background-color: ghostwhite;
      border-radius: 5px;
      border: 2px solid white;
      box-sizing: border-box;
    }

    /* Eyes serve as the charge indicator */
    #character::before,
    #character::after {
      content: '';
      position: absolute;
      width: 7px;
      height: 15px;
      background-color: #292A37;
      /* Default eye color */
      top: 10px;
      transition: background-color 0.1s;
    }

    #character::before {
      left: 12px;
    }

    #character::after {
      right: 12px;
    }

    .brick {
      position: absolute;
      width: 80px;
      height: 15px;
      background: ghostwhite;
      border-radius: 4px;
      transition: background-color 0.3s, opacity 0.3s;
    }

    /* Platform types styling */
    .brick.moving {
      background: #ff6f61;
      border: 2px solid #e94b3c;
    }

    .brick.disappearing {
      background: #6ab04c;
      border: 2px solid #4a7c2f;
    }

    #scoreDisplay {
      position: absolute;
      top: 15px;
      left: 15px;
      color: white;
      font-size: 24px;
      font-weight: bold;
      z-index: 10;
    }

    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(41, 42, 55, 0.85);
      color: white;
      display: none;
      /* Initially hidden */
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 20;
    }

    #gameOverScreen h2 {
      margin: 0;
      font-size: 48px;
    }

    #finalScore {
      font-size: 24px;
      margin: 20px 0;
    }

    #restartButton {
      padding: 15px 30px;
      font-size: 20px;
      cursor: pointer;
      border: 2px solid white;
      border-radius: 10px;
      background-color: transparent;
      color: white;
      font-weight: bold;
    }

    #restartButton:hover {
      background-color: ghostwhite;
      color: #292A37;
    }
  </style>
</head>

<body>
  <div id="gameContainer">
    <div id="scoreDisplay">Score: 0</div>
    <div id="character"></div>
    <div id="gameOverScreen">
      <h2>Game Over</h2>
      <p id="finalScore">Your Score: 0</p>
      <button id="restartButton">Restart</button>
    </div>
  </div>

  <script>
    const container = document.getElementById("gameContainer");
    const character = document.getElementById("character");
    const scoreDisplay = document.getElementById("scoreDisplay");
    const gameOverScreen = document.getElementById("gameOverScreen");
    const finalScoreDisplay = document.getElementById("finalScore");
    const restartButton = document.getElementById("restartButton");

   
    const GRAVITY = 0.8;
    const MAX_JUMP_POWER = 22;
    const MIN_JUMP_POWER = 6;
    const CHARGE_SPEED = 1.5;
    const HORIZONTAL_SPEED = 7;
    const WALL_BOUNCE_DAMPING = 0.5;
    const GROUND_FRICTION = 0.1;
    const CHARACTER_WIDTH = 50;
    const CHARACTER_HEIGHT = 50;
    const BRICK_WIDTH = 80;
    const BRICK_HEIGHT = 15;
    const TOTAL_BRICKS = 8;
    const SCROLL_THRESHOLD_TOP = window.innerHeight / 2.5;

 
    let positionX, positionY, velocityX, velocityY;
    let isCharging, jumpPower, jumpDirection;
    let isJumping;
    let chargeTimer;
    let score, highestY;
    let bricks = [];
    let gameState = 'playing'; // 'playing' or 'gameOver'

    // --- ADDED: Store brick data with types and extra properties ---
    let brickData = [];

    function resetGame() {
      // Reset variables
      positionX = container.clientWidth / 2 - CHARACTER_WIDTH / 2;
      positionY = container.clientHeight - CHARACTER_HEIGHT - 50;
      velocityX = 0;
      velocityY = 0;
      isCharging = false;
      isJumping = false;
      jumpPower = MIN_JUMP_POWER;
      jumpDirection = 0;
      score = 0;
      highestY = positionY;

      // Reset display
      scoreDisplay.textContent = "Score: 0";
      character.style.left = positionX + "px";
      character.style.top = positionY + "px";
      updateChargeIndicator(0);

      // Hide game over screen
      gameOverScreen.style.display = 'none';

      // Clear existing bricks and create new ones
      bricks.forEach(brick => brick.remove());
      bricks = [];
      brickData = [];
      createInitialBricks();

      // Start game
      gameState = 'playing';
      requestAnimationFrame(gameLoop);
    }

    function createInitialBricks() {
      // Create a starting platform (normal)
      createBrick(container.clientWidth / 2 - BRICK_WIDTH / 2, container.clientHeight - 50, 'normal');

      // Create random bricks with random types
      for (let i = 0; i < TOTAL_BRICKS; i++) {
        const type = randomPlatformType();
        createBrick(
          Math.random() * (container.clientWidth - BRICK_WIDTH),
          container.clientHeight - 150 - (i * 100),
          type
        );
      }
    }

    function randomPlatformType() {
      // 60% normal, 20% moving, 20% disappearing
      const rand = Math.random();
      if (rand < 0.6) return 'normal';
      else if (rand < 0.8) return 'moving';
      else return 'disappearing';
    }

    function createBrick(x, y, type = 'normal') {
      const brick = document.createElement("div");
      brick.className = "brick";
      if (type === 'moving') brick.classList.add('moving');
      if (type === 'disappearing') brick.classList.add('disappearing');

      brick.style.left = x + "px";
      brick.style.top = y + "px";
      container.appendChild(brick);
      bricks.push(brick);

      // Save brick data for logic handling
      brickData.push({
        element: brick,
        type: type,
        direction: 1, // for moving platforms (1 = right, -1 = left)
        speed: 2,     // speed of moving platform
        visible: true, // for disappearing platform
        disappearTimer: 0, // timer to reappear
      });
    }

    // --- JUMP MECHANICS ---
    function startCharge(direction) {
      if (isJumping || isCharging) return;

      isCharging = true;
      jumpDirection = direction;
      jumpPower = MIN_JUMP_POWER;

      chargeTimer = setInterval(() => {
        if (jumpPower < MAX_JUMP_POWER) {
          jumpPower += CHARGE_SPEED;
        }
        updateChargeIndicator(jumpPower);
      }, 20);
    }

    function releaseJump() {
      if (!isCharging) return;

      velocityX = HORIZONTAL_SPEED * jumpDirection;
      velocityY = -jumpPower;
      isCharging = false;
      isJumping = true;
      clearInterval(chargeTimer);
      updateChargeIndicator(0);
    }

    function updateChargeIndicator(power) {
      const chargeRatio = Math.min((power - MIN_JUMP_POWER) / (MAX_JUMP_POWER - MIN_JUMP_POWER), 1);
      const color = `rgb(${255 * chargeRatio}, ${255 * (1 - chargeRatio)}, 0)`;
      character.style.setProperty('--eye-color', color);
      character.style.background = `
            conic-gradient(from 90deg, var(--eye-color, #292A37), var(--eye-color, #292A37)),
            conic-gradient(from 90deg, var(--eye-color, #292A37), var(--eye-color, #292A37)),
            conic-gradient(ghostwhite, ghostwhite)`;
      character.style.backgroundSize = '7px 15px, 7px 15px, 50px 50px';
      character.style.backgroundPosition = '12px 10px, 31px 10px, 0 0';
      character.style.backgroundRepeat = 'no-repeat';
    }

    // --- INPUT HANDLERS ---
    container.addEventListener("touchstart", (e) => {
      e.preventDefault();
      const touchX = e.touches[0].clientX;
      const direction = touchX < container.clientWidth / 2 ? -1 : 1;
      startCharge(direction);
    }, {
      passive: false
    });

    container.addEventListener("touchend", (e) => {
      e.preventDefault();
      releaseJump();
    });

    window.addEventListener('keydown', (e) => {
      if (isJumping) return;
      if (e.key === ' ' || e.key === 'ArrowUp') {
        if (!isCharging) startCharge(velocityX > 0 ? 1 : (velocityX < 0 ? -1 : 1));
      }
      if (e.key === 'ArrowLeft') jumpDirection = -1;
      if (e.key === 'ArrowRight') jumpDirection = 1;
    });

    window.addEventListener('keyup', (e) => {
      if (e.key === ' ' || e.key === 'ArrowUp') {
        releaseJump();
      }
    });

    // --- COLLISION & PHYSICS ---
    function checkCollisions() {
      for (let i = 0; i < bricks.length; i++) {
        const brick = bricks[i];
        const data = brickData[i];

        const brickTop = brick.offsetTop;
        const brickLeft = brick.offsetLeft;

        // Collision only if brick visible (disappearing platforms can be invisible)
        if (!data.visible) continue;

        if (
          velocityY > 0 && // Moving down
          positionY + CHARACTER_HEIGHT >= brickTop &&
          positionY + CHARACTER_HEIGHT <= brickTop + BRICK_HEIGHT &&
          positionX + CHARACTER_WIDTH > brickLeft &&
          positionX < brickLeft + BRICK_WIDTH
        ) {
          positionY = brickTop - CHARACTER_HEIGHT;
          velocityY = 0;
          isJumping = false;

          // For moving platform, add platform velocity to character
          if (data.type === 'moving') {
            velocityX += data.speed * data.direction;
          }

          // For disappearing platform, start disappear countdown on landing
          if (data.type === 'disappearing') {
            data.disappearTimer = 60; // frames until disappear (about 1 second)
          }

          velocityX *= GROUND_FRICTION;
          if (Math.abs(velocityX) < 0.1) velocityX = 0;
          return;
        }
      }

      // Ground collision (normal ground)
      if (positionY >= container.clientHeight - CHARACTER_HEIGHT) {
        positionY = container.clientHeight - CHARACTER_HEIGHT;
        velocityY = 0;
        isJumping = false;
        velocityX *= GROUND_FRICTION;
        if (Math.abs(velocityX) < 0.1) velocityX = 0;
      }
    }

    function endGame() {
      gameState = 'gameOver';
      finalScoreDisplay.textContent = `Your Score: ${score}`;
      gameOverScreen.style.display = 'flex';
    }

    // --- MAIN GAME LOOP ---
    function gameLoop() {
      if (gameState !== 'playing') return;

      // Apply gravity
      velocityY += GRAVITY;

      // Update position
      positionX += velocityX;
      positionY += velocityY;

      // Wall bounces
      if (positionX < 0) {
        positionX = 0;
        velocityX *= -WALL_BOUNCE_DAMPING;
      } else if (positionX > container.clientWidth - CHARACTER_WIDTH) {
        positionX = container.clientWidth - CHARACTER_WIDTH;
        velocityX *= -WALL_BOUNCE_DAMPING;
      }

      checkCollisions();

      // Vertical scrolling
      if (positionY < SCROLL_THRESHOLD_TOP) {
        const scrollAmount = SCROLL_THRESHOLD_TOP - positionY;
        positionY += scrollAmount;

        // Move bricks down
        bricks.forEach((brick, i) => {
          const data = brickData[i];

          let newTop = brick.offsetTop + scrollAmount;

          // For moving platforms, update horizontal position as well
          if (data.type === 'moving') {
            let newLeft = brick.offsetLeft + data.speed * data.direction;

            // Bounce back if hitting sides
            if (newLeft < 0) {
              newLeft = 0;
              data.direction = 1;
            } else if (newLeft > container.clientWidth - BRICK_WIDTH) {
              newLeft = container.clientWidth - BRICK_WIDTH;
              data.direction = -1;
            }
            brick.style.left = newLeft + "px";
          }

          if (data.type === 'disappearing') {
            if (data.disappearTimer > 0) {
              data.disappearTimer--;
              if (data.disappearTimer === 0) {
                data.visible = false;
                brick.style.opacity = 0;
                // Reappear after 3 seconds (180 frames)
                setTimeout(() => {
                  data.visible = true;
                  brick.style.opacity = 1;
                }, 3000);
              }
            }
          }

          brick.style.top = newTop + "px";
        });

        highestY -= scrollAmount;
      }

      const currentHeight = Math.floor((highestY - positionY) / 10);
      if (currentHeight > score) {
        score = currentHeight;
        scoreDisplay.textContent = "Score: " + score;
      }


      character.style.left = positionX + "px";
      character.style.top = positionY + "px";

           bricks.forEach((brick, i) => {
        if (brick.offsetTop > container.clientHeight) {
          const data = brickData[i];
          brick.style.left = Math.random() * (container.clientWidth - BRICK_WIDTH) + 'px';
          brick.style.top = (brick.offsetTop - container.clientHeight - 200) + 'px';

          // Reset brickData properties
          if (data.type === 'disappearing') {
            data.visible = true;
            brick.style.opacity = 1;
            data.disappearTimer = 0;
          }
        }
      });

      // Game Over condition
      if (positionY > container.clientHeight) {
        endGame();
      }

      requestAnimationFrame(gameLoop);
    }

   
    restartButton.addEventListener('click', resetGame);
    resetGame();
  </script>
</body>

</html>
